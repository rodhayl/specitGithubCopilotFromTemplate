/**
 * DocSessionManager â€” Natural-language document creation and iterative refinement.
 *
 * Flow:
 *   1. User sends free-form text (no slash command, no active session).
 *   2. DocSessionManager classifies the intent via the local LLM to determine
 *      the document type and a concise title extracted from the message.
 *   3. An initial draft is generated by the appropriate specialist agent prompt
 *      and saved to the workspace.
 *   4. The session is pinned: every subsequent chat message is routed here,
 *      the current file is read, the LLM applies the user's feedback and
 *      produces the next focused question, and the file is written back.
 *   5. The user types `done`, `finish`, `/done`, or the LLM decides the
 *      document is complete â€” the session is closed.
 */
import * as vscode from 'vscode';
import * as path from 'path';
import { CommandContext } from '../commands/types';
import { FileUtils } from '../utils/FileUtils';

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export type DocType = 'prd' | 'requirements' | 'design' | 'spec' | 'brainstorm';

export interface DocSession {
    id: string;
    docType: DocType;
    agentName: string;
    documentPath: string;
    turnCount: number;
    createdAt: Date;
    lastActivity: Date;
}

export interface DocSessionResult {
    /** Markdown text to stream to the user */
    response: string;
    sessionId: string;
    documentPath: string;
    shouldContinue: boolean;
}

// â”€â”€â”€ Agent metadata â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const DOC_TYPE_META: Record<DocType, {
    agentName: string;
    agentTitle: string;
    folder: string;
    docLabel: string;
    systemPrompt: string;
}> = {
    prd: {
        agentName: 'prd-creator',
        agentTitle: 'PRD Creator',
        folder: 'docs/prd',
        docLabel: 'Product Requirements Document (PRD)',
        systemPrompt:
            `You are a senior product manager specialising in Product Requirements Documents (PRDs). ` +
            `Your role is to help the user develop a comprehensive PRD through focused conversation. ` +
            `Ask about goals, target users, key features, success metrics, and constraints. ` +
            `Each response should: (1) incorporate the user's latest input into the document, ` +
            `(2) ask exactly ONE focused follow-up question to uncover more detail.`
    },
    requirements: {
        agentName: 'requirements-gatherer',
        agentTitle: 'Requirements Gatherer',
        folder: 'docs/requirements',
        docLabel: 'Requirements Document',
        systemPrompt:
            `You are a senior business analyst specialising in requirements engineering. ` +
            `Your role is to help the user produce a thorough Requirements Document. ` +
            `Cover functional requirements, non-functional requirements, acceptance criteria, ` +
            `constraints, and dependencies. Each response should: (1) incorporate the user's ` +
            `latest input, (2) ask exactly ONE focused follow-up question.`
    },
    design: {
        agentName: 'solution-architect',
        agentTitle: 'Solution Architect',
        folder: 'docs/design',
        docLabel: 'Design Document',
        systemPrompt:
            `You are a senior solution architect. ` +
            `Your role is to help the user create a comprehensive Design Document covering ` +
            `system architecture, component design, data flows, API contracts, technology ` +
            `choices, and scalability considerations. Each response should: (1) incorporate ` +
            `the user's latest input, (2) ask exactly ONE focused follow-up question.`
    },
    spec: {
        agentName: 'specification-writer',
        agentTitle: 'Specification Writer',
        folder: 'docs/spec',
        docLabel: 'Technical Specification',
        systemPrompt:
            `You are a senior technical writer specialising in implementation specifications. ` +
            `Your role is to help the user create a detailed Technical Specification Document ` +
            `covering implementation tasks, interfaces, data models, error handling, and ` +
            `testing strategy. Each response should: (1) incorporate the user's latest input, ` +
            `(2) ask exactly ONE focused follow-up question.`
    },
    brainstorm: {
        agentName: 'brainstormer',
        agentTitle: 'Brainstormer',
        folder: 'docs/ideas',
        docLabel: 'Idea Document',
        systemPrompt:
            `You are a creative brainstorming facilitator. ` +
            `Your role is to help the user explore and expand their ideas into a well-structured ` +
            `Idea Document covering concept overview, motivations, potential approaches, ` +
            `opportunities, risks, and next steps. Each response should: (1) incorporate the ` +
            `user's latest input, (2) ask exactly ONE focused follow-up question to deepen ` +
            `the exploration.`
    }
};

// â”€â”€â”€ Session end signals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const DONE_PATTERNS = [
    /^\s*(\/done|done|finish|finished|complete|that['']s\s+it|looks\s+good|that\s+works)\s*[!.]?\s*$/i
];

function userWantsDone(input: string): boolean {
    return DONE_PATTERNS.some(p => p.test(input));
}

// â”€â”€â”€ Main class â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export class DocSessionManager {
    private static instance: DocSessionManager | undefined;
    private sessions = new Map<string, DocSession>();

    private constructor() {}

    static getInstance(): DocSessionManager {
        if (!DocSessionManager.instance) {
            DocSessionManager.instance = new DocSessionManager();
        }
        return DocSessionManager.instance;
    }

    /** Returns true if the given sessionId is an active DocSession */
    hasSession(sessionId: string): boolean {
        return this.sessions.has(sessionId);
    }

    /** Returns the active session, or undefined */
    getSession(sessionId: string): DocSession | undefined {
        return this.sessions.get(sessionId);
    }

    /** Call when VS Code extension deactivates to clean up */
    clearAll(): void {
        this.sessions.clear();
    }

    // â”€â”€ Public entry points â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /**
     * Start a brand-new document session from free-form user text.
     * Classifies intent, creates the file, stores the session,
     * and returns the first question to the user.
     */
    async startNewSession(
        input: string,
        context: CommandContext
    ): Promise<DocSessionResult> {
        const model = context.model;
        if (!model) {
            return this.noModelFallback();
        }

        // 1. Classify intent â†’ doc type + title
        const classification = await this.classifyIntent(input, model, context.token);

        // 2. Generate initial document draft
        const meta = DOC_TYPE_META[classification.docType];
        const draftContent = await this.generateInitialDraft(
            classification.title,
            input,
            classification.docType,
            meta,
            model,
            context.token
        );

        // 3. Save the file
        const documentPath = this.buildFilePath(
            context.workspaceRoot,
            meta.folder,
            classification.title
        );
        await this.writeDocumentFile(documentPath, draftContent);

        // 4. Generate the first focused question
        const firstQuestion = await this.generateFirstQuestion(
            classification.title,
            draftContent,
            classification.docType,
            meta,
            model,
            context.token
        );

        // 5. Register session
        const sessionId = `docsess_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
        const session: DocSession = {
            id: sessionId,
            docType: classification.docType,
            agentName: meta.agentName,
            documentPath,
            turnCount: 1,
            createdAt: new Date(),
            lastActivity: new Date()
        };
        this.sessions.set(sessionId, session);

        const relPath = path.relative(context.workspaceRoot, documentPath).replace(/\\/g, '/');
        const response =
            `## ğŸ¤– ${meta.agentTitle} â€” New ${meta.docLabel}\n\n` +
            `âœ… Created \`${relPath}\` with an initial draft.\n\n` +
            `---\n\n` +
            `${firstQuestion}\n\n` +
            `---\n` +
            `*Just reply to continue. Type \`done\` when you're happy with the document.*`;

        return { response, sessionId, documentPath, shouldContinue: true };
    }

    /**
     * Continue an existing session: read file â†’ apply feedback â†’ write â†’ next question.
     */
    async continueSession(
        sessionId: string,
        input: string,
        context: CommandContext
    ): Promise<DocSessionResult> {
        const session = this.sessions.get(sessionId)!;
        const model = context.model;

        // User signalled they're done
        if (userWantsDone(input)) {
            this.sessions.delete(sessionId);
            const relPath = path.relative(context.workspaceRoot, session.documentPath).replace(/\\/g, '/');
            return {
                response:
                    `âœ… **Session complete!** Your ${DOC_TYPE_META[session.docType].docLabel} is saved at \`${relPath}\`.\n\n` +
                    `You can:\n` +
                    `- Open the file to review the final document\n` +
                    `- Start a new session by describing your next project\n` +
                    `- Use \`/review --file "${relPath}"\` for a quality review`,
                sessionId,
                documentPath: session.documentPath,
                shouldContinue: false
            };
        }

        if (!model) {
            // No LLM â€” just acknowledge and keep session alive
            session.turnCount++;
            session.lastActivity = new Date();
            const relPath = path.relative(context.workspaceRoot, session.documentPath).replace(/\\/g, '/');
            return {
                response:
                    `ğŸ’¬ Got your feedback. The file is at \`${relPath}\`.\n` +
                    `*(No language model is currently selected â€” connect a model to enable automatic document updates.)*`,
                sessionId,
                documentPath: session.documentPath,
                shouldContinue: true
            };
        }

        // Read current file
        const currentContent = await this.readDocumentFile(session.documentPath);

        // Ask LLM to refine
        const meta = DOC_TYPE_META[session.docType];
        const refinedResult = await this.refineDocument(
            currentContent,
            input,
            session,
            meta,
            model,
            context.token
        );

        // Write updated content back
        if (refinedResult.updatedContent) {
            await this.writeDocumentFile(session.documentPath, refinedResult.updatedContent);
        }

        // Update session
        session.turnCount++;
        session.lastActivity = new Date();

        const relPath = path.relative(context.workspaceRoot, session.documentPath).replace(/\\/g, '/');
        const updateNote = refinedResult.updatedContent
            ? `ğŸ“ *Document updated* (\`${relPath}\`, turn ${session.turnCount})\n\n`
            : '';

        const response =
            updateNote +
            `${refinedResult.nextQuestion}\n\n` +
            `---\n*Type \`done\` when you're satisfied with the document.*`;

        return { response, sessionId, documentPath: session.documentPath, shouldContinue: true };
    }

    // â”€â”€ Private helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /** Classify user intent using the LLM */
    private async classifyIntent(
        input: string,
        model: vscode.LanguageModelChat,
        token: vscode.CancellationToken
    ): Promise<{ docType: DocType; title: string }> {
        const prompt = vscode.LanguageModelChatMessage.User(
            `Classify the following user message into exactly one document type and extract a concise title.\n\n` +
            `Document types:\n` +
            `- prd: Product Requirements Document â€” new product/feature ideas, MVP definitions\n` +
            `- requirements: Requirements Document â€” functional/non-functional requirements, user stories\n` +
            `- design: Design Document â€” system architecture, component design, technology choices\n` +
            `- spec: Technical Specification â€” implementation tasks, interfaces, data models\n` +
            `- brainstorm: Idea / Brainstorming â€” exploratory ideas, concepts, not yet a formal doc type\n\n` +
            `User message: "${input}"\n\n` +
            `Respond with ONLY a JSON object like this (no markdown, no explanation):\n` +
            `{"docType": "prd", "title": "Concise Title Here"}`
        );

        try {
            const response = await model.sendRequest([prompt], {}, token);
            let raw = '';
            for await (const chunk of response.text) { raw += chunk; }
            // Strip possible markdown fences
            const jsonStr = raw.replace(/```json\s*/gi, '').replace(/```\s*/g, '').trim();
            const parsed = JSON.parse(jsonStr);
            const docType = (['prd', 'requirements', 'design', 'spec', 'brainstorm'] as DocType[]).includes(parsed.docType)
                ? (parsed.docType as DocType)
                : 'prd';
            const title = (typeof parsed.title === 'string' && parsed.title.trim())
                ? parsed.title.trim()
                : 'New Document';
            return { docType, title };
        } catch {
            // Fallback: default to prd, derive title from first ~8 words
            const words = input.trim().split(/\s+/).slice(0, 8).join(' ');
            return { docType: 'prd', title: words || 'New Document' };
        }
    }

    /** Generate a full initial draft using the LLM */
    private async generateInitialDraft(
        title: string,
        userMessage: string,
        docType: DocType,
        meta: typeof DOC_TYPE_META[DocType],
        model: vscode.LanguageModelChat,
        token: vscode.CancellationToken
    ): Promise<string> {
        const prompt = vscode.LanguageModelChatMessage.User(
            `${meta.systemPrompt}\n\n` +
            `The user wants to create a ${meta.docLabel} titled: "${title}".\n\n` +
            `Initial context from user:\n${userMessage}\n\n` +
            `Generate a comprehensive initial draft in Markdown. ` +
            `Use proper headings (##, ###). Include all relevant sections for a ${meta.docLabel}. ` +
            `Where you lack information, use "[TBD â€” see conversation]" as placeholder. ` +
            `Do NOT ask questions in the draft â€” just write the document.`
        );

        try {
            const response = await model.sendRequest([prompt], {}, token);
            let content = '';
            for await (const chunk of response.text) { content += chunk; }
            return content.trim() || `# ${title}\n\n*[Initial draft â€” content pending user input]*`;
        } catch {
            return `# ${title}\n\n*[Initial draft â€” language model unavailable]*`;
        }
    }

    /** Generate the first targeted question after the initial draft */
    private async generateFirstQuestion(
        title: string,
        draftContent: string,
        docType: DocType,
        meta: typeof DOC_TYPE_META[DocType],
        model: vscode.LanguageModelChat,
        token: vscode.CancellationToken
    ): Promise<string> {
        const prompt = vscode.LanguageModelChatMessage.User(
            `${meta.systemPrompt}\n\n` +
            `You just created an initial draft of a ${meta.docLabel} titled "${title}".\n\n` +
            `Here is the draft:\n\`\`\`\n${draftContent.slice(0, 3000)}\n\`\`\`\n\n` +
            `Ask the single most important follow-up question to help refine this document. ` +
            `Be specific â€” refer to the content of the draft. ` +
            `Output ONLY the question (no preamble, no options list).`
        );

        try {
            const response = await model.sendRequest([prompt], {}, token);
            let question = '';
            for await (const chunk of response.text) { question += chunk; }
            return question.trim() || 'What are the most important aspects you would like to elaborate on?';
        } catch {
            return 'What are the key objectives and success criteria for this project?';
        }
    }

    /**
     * Ask the LLM to apply user feedback to the existing document and produce
     * the next refinement question.  Uses a structured "---DOCUMENT---" /
     * "---QUESTION---" delimiter so we can reliably split the response.
     */
    private async refineDocument(
        currentContent: string,
        userFeedback: string,
        session: DocSession,
        meta: typeof DOC_TYPE_META[DocType],
        model: vscode.LanguageModelChat,
        token: vscode.CancellationToken
    ): Promise<{ updatedContent: string | null; nextQuestion: string }> {
        const MAX_DOC_CHARS = 6000; // keep prompt manageable
        const truncatedContent = currentContent.length > MAX_DOC_CHARS
            ? currentContent.slice(0, MAX_DOC_CHARS) + '\n\n[... document truncated for context ...]'
            : currentContent;

        const prompt = vscode.LanguageModelChatMessage.User(
            `${meta.systemPrompt}\n\n` +
            `You are refining a ${meta.docLabel} (turn ${session.turnCount + 1}).\n\n` +
            `--- CURRENT DOCUMENT ---\n${truncatedContent}\n--- END DOCUMENT ---\n\n` +
            `User feedback / new information:\n"${userFeedback}"\n\n` +
            `Instructions:\n` +
            `1. Produce a fully updated version of the document incorporating this feedback.\n` +
            `2. After updating, ask ONE focused follow-up question to further improve it.\n\n` +
            `Respond using EXACTLY this format (include the delimiter lines as shown):\n` +
            `---DOCUMENT---\n` +
            `[full updated markdown document here]\n` +
            `---QUESTION---\n` +
            `[one focused follow-up question here]`
        );

        try {
            const response = await model.sendRequest([prompt], {}, token);
            let raw = '';
            for await (const chunk of response.text) { raw += chunk; }

            const docIndex = raw.indexOf('---DOCUMENT---');
            const qIndex = raw.indexOf('---QUESTION---');

            if (docIndex !== -1 && qIndex !== -1 && qIndex > docIndex) {
                const updatedContent = raw.slice(docIndex + '---DOCUMENT---'.length, qIndex).trim();
                const nextQuestion = raw.slice(qIndex + '---QUESTION---'.length).trim();
                return {
                    updatedContent: updatedContent || null,
                    nextQuestion: nextQuestion || 'What else would you like to refine?'
                };
            }

            // Fallback: no delimiters found â€” treat entire response as the question
            return { updatedContent: null, nextQuestion: raw.trim() || 'What else would you like to add?' };
        } catch {
            return { updatedContent: null, nextQuestion: 'What aspect would you like to work on next?' };
        }
    }

    // â”€â”€ File I/O â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    private buildFilePath(workspaceRoot: string, folder: string, title: string): string {
        const safe = title
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '')
            .slice(0, 60) || 'document';
        return path.join(workspaceRoot, folder, `${safe}.md`);
    }

    private async writeDocumentFile(filePath: string, content: string): Promise<void> {
        await FileUtils.ensureDirectoryExists(path.dirname(filePath));
        await vscode.workspace.fs.writeFile(
            vscode.Uri.file(filePath),
            Buffer.from(content, 'utf8')
        );
    }

    private async readDocumentFile(filePath: string): Promise<string> {
        try {
            const bytes = await vscode.workspace.fs.readFile(vscode.Uri.file(filePath));
            return Buffer.from(bytes).toString('utf8');
        } catch {
            return '';
        }
    }

    // â”€â”€ Fallbacks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    private noModelFallback(): DocSessionResult {
        return {
            response:
                `ğŸ‘‹ **No language model is selected.**\n\n` +
                `To use natural-language document creation, select a model in the chat toolbar above.\n\n` +
                `Alternatively, use slash commands:\n` +
                `- \`/new "Your Project Title"\` to create a document\n` +
                `- \`/prd "Title"\` for a Product Requirements Document\n` +
                `- \`/requirements\` to start requirements gathering`,
            sessionId: '',
            documentPath: '',
            shouldContinue: false
        };
    }
}
